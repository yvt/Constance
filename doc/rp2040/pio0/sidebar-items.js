initSidebarItems({"mod":[["ctrl","PIO control register"],["dbg_cfginfo","The PIO hardware has some free parameters that may vary between chip products.\\n These should be provided in the chip datasheet, but are also exposed here."],["dbg_padoe","Read to sample the pad output enables (direction) PIO is currently driving to the GPIOs."],["dbg_padout","Read to sample the pad output values PIO is currently driving to the GPIOs."],["fdebug","FIFO debug register"],["flevel","FIFO levels"],["fstat","FIFO status register"],["input_sync_bypass","There is a 2-flipflop synchronizer on each GPIO input, which protects\\n PIO logic from metastabilities. This increases input delay, and for fast\\n synchronous IO (e.g. SPI) these synchronizers may need to be bypassed.\\n Each bit in this register corresponds to one GPIO.\\n 0 -> input is synchronized (default)\\n 1 -> synchronizer is bypassed\\n If in doubt, leave this register as all zeroes."],["instr_mem0","Write-only access to instruction memory location 0"],["instr_mem1","Write-only access to instruction memory location 1"],["instr_mem10","Write-only access to instruction memory location 10"],["instr_mem11","Write-only access to instruction memory location 11"],["instr_mem12","Write-only access to instruction memory location 12"],["instr_mem13","Write-only access to instruction memory location 13"],["instr_mem14","Write-only access to instruction memory location 14"],["instr_mem15","Write-only access to instruction memory location 15"],["instr_mem16","Write-only access to instruction memory location 16"],["instr_mem17","Write-only access to instruction memory location 17"],["instr_mem18","Write-only access to instruction memory location 18"],["instr_mem19","Write-only access to instruction memory location 19"],["instr_mem2","Write-only access to instruction memory location 2"],["instr_mem20","Write-only access to instruction memory location 20"],["instr_mem21","Write-only access to instruction memory location 21"],["instr_mem22","Write-only access to instruction memory location 22"],["instr_mem23","Write-only access to instruction memory location 23"],["instr_mem24","Write-only access to instruction memory location 24"],["instr_mem25","Write-only access to instruction memory location 25"],["instr_mem26","Write-only access to instruction memory location 26"],["instr_mem27","Write-only access to instruction memory location 27"],["instr_mem28","Write-only access to instruction memory location 28"],["instr_mem29","Write-only access to instruction memory location 29"],["instr_mem3","Write-only access to instruction memory location 3"],["instr_mem30","Write-only access to instruction memory location 30"],["instr_mem31","Write-only access to instruction memory location 31"],["instr_mem4","Write-only access to instruction memory location 4"],["instr_mem5","Write-only access to instruction memory location 5"],["instr_mem6","Write-only access to instruction memory location 6"],["instr_mem7","Write-only access to instruction memory location 7"],["instr_mem8","Write-only access to instruction memory location 8"],["instr_mem9","Write-only access to instruction memory location 9"],["intr","Raw Interrupts"],["irq","Interrupt request register. Write 1 to clear"],["irq0_inte","Interrupt Enable for irq0"],["irq0_intf","Interrupt Force for irq0"],["irq0_ints","Interrupt status after masking & forcing for irq0"],["irq1_inte","Interrupt Enable for irq1"],["irq1_intf","Interrupt Force for irq1"],["irq1_ints","Interrupt status after masking & forcing for irq1"],["irq_force","Writing a 1 to each of these bits will forcibly assert the corresponding IRQ.\\n Note this is different to the INTF register: writing here affects PIO internal\\n state. INTF just asserts the processor-facing IRQ signal for testing ISRs,\\n and is not visible to the state machines."],["rxf0","Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO."],["rxf1","Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO."],["rxf2","Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO."],["rxf3","Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO."],["sm0_addr","Current instruction address of state machine 0"],["sm0_clkdiv","Clock divider register for state machine 0\\n Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)"],["sm0_execctrl","Execution/behavioural settings for state machine 0"],["sm0_instr","Instruction currently being executed by state machine 0\\n Write to execute an instruction immediately (including jumps) and then resume execution."],["sm0_pinctrl","State machine pin control"],["sm0_shiftctrl","Control behaviour of the input/output shift registers for state machine 0"],["sm1_addr","Current instruction address of state machine 1"],["sm1_clkdiv","Clock divider register for state machine 1\\n Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)"],["sm1_execctrl","Execution/behavioural settings for state machine 1"],["sm1_instr","Instruction currently being executed by state machine 1\\n Write to execute an instruction immediately (including jumps) and then resume execution."],["sm1_pinctrl","State machine pin control"],["sm1_shiftctrl","Control behaviour of the input/output shift registers for state machine 1"],["sm2_addr","Current instruction address of state machine 2"],["sm2_clkdiv","Clock divider register for state machine 2\\n Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)"],["sm2_execctrl","Execution/behavioural settings for state machine 2"],["sm2_instr","Instruction currently being executed by state machine 2\\n Write to execute an instruction immediately (including jumps) and then resume execution."],["sm2_pinctrl","State machine pin control"],["sm2_shiftctrl","Control behaviour of the input/output shift registers for state machine 2"],["sm3_addr","Current instruction address of state machine 3"],["sm3_clkdiv","Clock divider register for state machine 3\\n Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)"],["sm3_execctrl","Execution/behavioural settings for state machine 3"],["sm3_instr","Instruction currently being executed by state machine 3\\n Write to execute an instruction immediately (including jumps) and then resume execution."],["sm3_pinctrl","State machine pin control"],["sm3_shiftctrl","Control behaviour of the input/output shift registers for state machine 3"],["txf0","Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO."],["txf1","Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO."],["txf2","Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO."],["txf3","Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO."]],"struct":[["RegisterBlock","Register block"]],"type":[["CTRL","PIO control register"],["DBG_CFGINFO","The PIO hardware has some free parameters that may vary between chip products.\\n These should be provided in the chip datasheet, but are also exposed here."],["DBG_PADOE","Read to sample the pad output enables (direction) PIO is currently driving to the GPIOs."],["DBG_PADOUT","Read to sample the pad output values PIO is currently driving to the GPIOs."],["FDEBUG","FIFO debug register"],["FLEVEL","FIFO levels"],["FSTAT","FIFO status register"],["INPUT_SYNC_BYPASS","There is a 2-flipflop synchronizer on each GPIO input, which protects\\n PIO logic from metastabilities. This increases input delay, and for fast\\n synchronous IO (e.g. SPI) these synchronizers may need to be bypassed.\\n Each bit in this register corresponds to one GPIO.\\n 0 -> input is synchronized (default)\\n 1 -> synchronizer is bypassed\\n If in doubt, leave this register as all zeroes."],["INSTR_MEM0","Write-only access to instruction memory location 0"],["INSTR_MEM1","Write-only access to instruction memory location 1"],["INSTR_MEM10","Write-only access to instruction memory location 10"],["INSTR_MEM11","Write-only access to instruction memory location 11"],["INSTR_MEM12","Write-only access to instruction memory location 12"],["INSTR_MEM13","Write-only access to instruction memory location 13"],["INSTR_MEM14","Write-only access to instruction memory location 14"],["INSTR_MEM15","Write-only access to instruction memory location 15"],["INSTR_MEM16","Write-only access to instruction memory location 16"],["INSTR_MEM17","Write-only access to instruction memory location 17"],["INSTR_MEM18","Write-only access to instruction memory location 18"],["INSTR_MEM19","Write-only access to instruction memory location 19"],["INSTR_MEM2","Write-only access to instruction memory location 2"],["INSTR_MEM20","Write-only access to instruction memory location 20"],["INSTR_MEM21","Write-only access to instruction memory location 21"],["INSTR_MEM22","Write-only access to instruction memory location 22"],["INSTR_MEM23","Write-only access to instruction memory location 23"],["INSTR_MEM24","Write-only access to instruction memory location 24"],["INSTR_MEM25","Write-only access to instruction memory location 25"],["INSTR_MEM26","Write-only access to instruction memory location 26"],["INSTR_MEM27","Write-only access to instruction memory location 27"],["INSTR_MEM28","Write-only access to instruction memory location 28"],["INSTR_MEM29","Write-only access to instruction memory location 29"],["INSTR_MEM3","Write-only access to instruction memory location 3"],["INSTR_MEM30","Write-only access to instruction memory location 30"],["INSTR_MEM31","Write-only access to instruction memory location 31"],["INSTR_MEM4","Write-only access to instruction memory location 4"],["INSTR_MEM5","Write-only access to instruction memory location 5"],["INSTR_MEM6","Write-only access to instruction memory location 6"],["INSTR_MEM7","Write-only access to instruction memory location 7"],["INSTR_MEM8","Write-only access to instruction memory location 8"],["INSTR_MEM9","Write-only access to instruction memory location 9"],["INTR","Raw Interrupts"],["IRQ","Interrupt request register. Write 1 to clear"],["IRQ0_INTE","Interrupt Enable for irq0"],["IRQ0_INTF","Interrupt Force for irq0"],["IRQ0_INTS","Interrupt status after masking & forcing for irq0"],["IRQ1_INTE","Interrupt Enable for irq1"],["IRQ1_INTF","Interrupt Force for irq1"],["IRQ1_INTS","Interrupt status after masking & forcing for irq1"],["IRQ_FORCE","Writing a 1 to each of these bits will forcibly assert the corresponding IRQ.\\n Note this is different to the INTF register: writing here affects PIO internal\\n state. INTF just asserts the processor-facing IRQ signal for testing ISRs,\\n and is not visible to the state machines."],["RXF0","Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO."],["RXF1","Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO."],["RXF2","Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO."],["RXF3","Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO."],["SM0_ADDR","Current instruction address of state machine 0"],["SM0_CLKDIV","Clock divider register for state machine 0\\n Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)"],["SM0_EXECCTRL","Execution/behavioural settings for state machine 0"],["SM0_INSTR","Instruction currently being executed by state machine 0\\n Write to execute an instruction immediately (including jumps) and then resume execution."],["SM0_PINCTRL","State machine pin control"],["SM0_SHIFTCTRL","Control behaviour of the input/output shift registers for state machine 0"],["SM1_ADDR","Current instruction address of state machine 1"],["SM1_CLKDIV","Clock divider register for state machine 1\\n Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)"],["SM1_EXECCTRL","Execution/behavioural settings for state machine 1"],["SM1_INSTR","Instruction currently being executed by state machine 1\\n Write to execute an instruction immediately (including jumps) and then resume execution."],["SM1_PINCTRL","State machine pin control"],["SM1_SHIFTCTRL","Control behaviour of the input/output shift registers for state machine 1"],["SM2_ADDR","Current instruction address of state machine 2"],["SM2_CLKDIV","Clock divider register for state machine 2\\n Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)"],["SM2_EXECCTRL","Execution/behavioural settings for state machine 2"],["SM2_INSTR","Instruction currently being executed by state machine 2\\n Write to execute an instruction immediately (including jumps) and then resume execution."],["SM2_PINCTRL","State machine pin control"],["SM2_SHIFTCTRL","Control behaviour of the input/output shift registers for state machine 2"],["SM3_ADDR","Current instruction address of state machine 3"],["SM3_CLKDIV","Clock divider register for state machine 3\\n Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)"],["SM3_EXECCTRL","Execution/behavioural settings for state machine 3"],["SM3_INSTR","Instruction currently being executed by state machine 3\\n Write to execute an instruction immediately (including jumps) and then resume execution."],["SM3_PINCTRL","State machine pin control"],["SM3_SHIFTCTRL","Control behaviour of the input/output shift registers for state machine 3"],["TXF0","Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO."],["TXF1","Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO."],["TXF2","Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO."],["TXF3","Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO."]]});